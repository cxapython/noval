# 🚀 插件化改造快速指南

> 从当前系统平滑升级到插件化+可视化流程编辑器

## 📌 第一步：后端插件化（今天完成）

### 1.1 创建插件目录结构

```bash
cd /Users/chennan/pythonproject/demo/noval/backend
mkdir -p plugins/custom
touch plugins/__init__.py
touch plugins/base.py
touch plugins/builtin.py
touch plugins/custom/__init__.py
```

### 1.2 创建插件基类（backend/plugins/base.py）

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
插件系统基础架构
"""
from typing import Any, Dict, List
from loguru import logger


class ProcessorPlugin:
    """清洗规则插件基类"""
    
    category = 'processor'  # 插件分类：processor, extractor, validator
    description = ''        # 插件描述
    
    def process(self, data: Any, params: Dict) -> Any:
        """
        处理数据
        :param data: 输入数据
        :param params: 参数配置
        :return: 处理后的数据
        """
        raise NotImplementedError
    
    def validate_params(self, params: Dict) -> bool:
        """
        验证参数是否合法（可选重写）
        :param params: 参数配置
        :return: 是否合法
        """
        return True


class PluginRegistry:
    """插件注册器 - 管理所有插件"""
    
    _plugins: Dict[str, ProcessorPlugin] = {}
    
    @classmethod
    def register(cls, name: str):
        """
        装饰器：注册插件
        
        用法：
        @PluginRegistry.register('my_processor')
        class MyProcessor(ProcessorPlugin):
            pass
        """
        def decorator(plugin_class):
            try:
                instance = plugin_class()
                cls._plugins[name] = instance
                logger.debug(f"✅ 注册插件: {name} ({plugin_class.__name__})")
            except Exception as e:
                logger.error(f"❌ 插件注册失败 {name}: {e}")
            return plugin_class
        return decorator
    
    @classmethod
    def get(cls, name: str) -> ProcessorPlugin:
        """获取插件实例"""
        return cls._plugins.get(name)
    
    @classmethod
    def list_all(cls) -> List[str]:
        """列出所有已注册插件名称"""
        return list(cls._plugins.keys())
    
    @classmethod
    def get_plugin_info(cls, name: str) -> Dict:
        """获取插件详细信息"""
        plugin = cls._plugins.get(name)
        if not plugin:
            return None
        
        return {
            'name': name,
            'category': plugin.category,
            'description': plugin.description or plugin.__class__.__doc__ or '',
            'class_name': plugin.__class__.__name__
        }
    
    @classmethod
    def list_by_category(cls, category: str = None) -> Dict:
        """按分类列出插件"""
        if category:
            return {
                name: plugin for name, plugin in cls._plugins.items()
                if plugin.category == category
            }
        
        # 按分类分组
        result = {}
        for name, plugin in cls._plugins.items():
            cat = plugin.category
            if cat not in result:
                result[cat] = {}
            result[cat][name] = plugin
        
        return result
```

### 1.3 迁移内置插件（backend/plugins/builtin.py）

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
内置清洗规则插件
"""
import re
from typing import Any, Dict, List
from loguru import logger
from .base import ProcessorPlugin, PluginRegistry


@PluginRegistry.register('strip')
class StripProcessor(ProcessorPlugin):
    """去除首尾空白字符"""
    
    category = 'processor'
    description = '去除字符串首尾的空白字符（空格、制表符、换行符等）'
    
    def process(self, data: Any, params: Dict) -> Any:
        chars = params.get('chars', None)
        
        if isinstance(data, str):
            return data.strip(chars)
        elif isinstance(data, list):
            return [item.strip(chars) if isinstance(item, str) else item for item in data]
        
        return data


@PluginRegistry.register('replace')
class ReplaceProcessor(ProcessorPlugin):
    """字符串替换"""
    
    category = 'processor'
    description = '将字符串中的指定内容替换为新内容'
    
    def process(self, data: Any, params: Dict) -> Any:
        old = params.get('old', '')
        new = params.get('new', '')
        
        if isinstance(data, str):
            # 智能处理：兼容普通空格和\xa0（不间断空格）
            if old in data:
                return data.replace(old, new)
            else:
                normalized_data = data.replace('\xa0', ' ')
                normalized_old = old.replace('\xa0', ' ')
                if normalized_old in normalized_data:
                    return normalized_data.replace(normalized_old, new)
            return data
        elif isinstance(data, list):
            return [item.replace(old, new) if isinstance(item, str) else item for item in data]
        
        return data
    
    def validate_params(self, params: Dict) -> bool:
        return 'old' in params and 'new' in params


@PluginRegistry.register('regex_replace')
class RegexReplaceProcessor(ProcessorPlugin):
    """正则表达式替换"""
    
    category = 'processor'
    description = '使用正则表达式匹配并替换字符串内容'
    
    def process(self, data: Any, params: Dict) -> Any:
        pattern = params.get('pattern', '')
        repl = params.get('repl', '')
        
        if isinstance(data, str):
            return re.sub(pattern, repl, data)
        elif isinstance(data, list):
            return [re.sub(pattern, repl, item) if isinstance(item, str) else item for item in data]
        
        return data
    
    def validate_params(self, params: Dict) -> bool:
        if 'pattern' not in params:
            return False
        try:
            re.compile(params['pattern'])
            return True
        except re.error:
            return False


@PluginRegistry.register('join')
class JoinProcessor(ProcessorPlugin):
    """数组元素连接为字符串"""
    
    category = 'processor'
    description = '将数组元素用指定分隔符连接成一个字符串'
    
    def process(self, data: Any, params: Dict) -> Any:
        if isinstance(data, list):
            separator = params.get('separator', '')
            return separator.join([str(item) for item in data])
        return data


@PluginRegistry.register('split')
class SplitProcessor(ProcessorPlugin):
    """字符串分割为数组"""
    
    category = 'processor'
    description = '将字符串按指定分隔符分割成数组'
    
    def process(self, data: Any, params: Dict) -> Any:
        if isinstance(data, str):
            separator = params.get('separator', ' ')
            return data.split(separator)
        return data


@PluginRegistry.register('extract_first')
class ExtractFirstProcessor(ProcessorPlugin):
    """提取数组第一个元素"""
    
    category = 'processor'
    description = '从数组中提取第一个元素'
    
    def process(self, data: Any, params: Dict) -> Any:
        if isinstance(data, list) and len(data) > 0:
            return data[0]
        return data


@PluginRegistry.register('extract_index')
class ExtractIndexProcessor(ProcessorPlugin):
    """提取数组指定索引的元素"""
    
    category = 'processor'
    description = '从数组中提取指定索引位置的元素'
    
    def process(self, data: Any, params: Dict) -> Any:
        if isinstance(data, list):
            idx = params.get('index', 0)
            try:
                return data[idx]
            except IndexError:
                logger.warning(f"索引 {idx} 超出范围 (数组长度: {len(data)})")
                return None
        return data
    
    def validate_params(self, params: Dict) -> bool:
        return 'index' in params and isinstance(params['index'], int)


# 导出所有插件（方便import）
__all__ = [
    'StripProcessor',
    'ReplaceProcessor',
    'RegexReplaceProcessor',
    'JoinProcessor',
    'SplitProcessor',
    'ExtractFirstProcessor',
    'ExtractIndexProcessor'
]
```

### 1.4 修改 parser.py

在 `backend/parser.py` 顶部添加导入：

```python
# 在现有导入后添加
from backend.plugins.base import PluginRegistry
from backend.plugins import builtin  # 自动注册所有内置插件
```

替换 `apply_post_process` 方法：

```python
def apply_post_process(self, data: Any, processes: List[Dict]) -> Any:
    """
    应用后处理（插件化版本）
    :param data: 原始数据
    :param processes: 处理步骤列表
    :return: 处理后的数据
    """
    result = data
    
    for process in processes:
        method = process.get('method', '')
        params = process.get('params', {})
        
        try:
            # 从插件注册器获取处理器
            processor = PluginRegistry.get(method)
            if processor:
                # 验证参数
                if processor.validate_params(params):
                    result = processor.process(result, params)
                else:
                    logger.warning(f"⚠️  插件 {method} 参数验证失败: {params}")
            else:
                logger.warning(f"⚠️  未找到清洗插件: {method}")
        
        except Exception as e:
            logger.warning(f"⚠️  插件 {method} 处理失败: {e}")
    
    return result
```

**可选：保留旧方法作为备份（注释掉）**

### 1.5 添加API端点

在 `backend/api.py` 或 `backend/routes/crawler.py` 添加：

```python
from backend.plugins.base import PluginRegistry

@app.route('/api/plugins/list', methods=['GET'])
def list_plugins():
    """列出所有可用插件"""
    try:
        plugins = PluginRegistry.list_all()
        plugin_info = [
            PluginRegistry.get_plugin_info(name) 
            for name in plugins
        ]
        
        return jsonify({
            'success': True,
            'plugins': plugin_info,
            'count': len(plugin_info)
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@app.route('/api/plugins/<name>', methods=['GET'])
def get_plugin_info(name):
    """获取单个插件详情"""
    info = PluginRegistry.get_plugin_info(name)
    if info:
        return jsonify({
            'success': True,
            'plugin': info
        })
    else:
        return jsonify({
            'success': False,
            'error': f'插件不存在: {name}'
        }), 404
```

### 1.6 测试验证

创建 `tests/test_plugin_system.py`：

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import sys
from pathlib import Path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from backend.plugins.base import PluginRegistry
from backend.plugins import builtin

def test_plugin_registration():
    """测试插件注册"""
    plugins = PluginRegistry.list_all()
    print(f"✅ 已注册 {len(plugins)} 个插件:")
    for name in plugins:
        info = PluginRegistry.get_plugin_info(name)
        print(f"   - {name}: {info['description']}")
    
    assert 'strip' in plugins
    assert 'replace' in plugins
    assert 'join' in plugins

def test_strip_plugin():
    """测试strip插件"""
    processor = PluginRegistry.get('strip')
    assert processor is not None
    
    result = processor.process('  hello  ', {})
    assert result == 'hello'
    print("✅ strip插件测试通过")

def test_replace_plugin():
    """测试replace插件"""
    processor = PluginRegistry.get('replace')
    assert processor is not None
    
    result = processor.process('hello world', {'old': 'world', 'new': 'python'})
    assert result == 'hello python'
    print("✅ replace插件测试通过")

def test_join_plugin():
    """测试join插件"""
    processor = PluginRegistry.get('join')
    assert processor is not None
    
    result = processor.process(['a', 'b', 'c'], {'separator': '-'})
    assert result == 'a-b-c'
    print("✅ join插件测试通过")

if __name__ == '__main__':
    test_plugin_registration()
    test_strip_plugin()
    test_replace_plugin()
    test_join_plugin()
    print("\n🎉 所有测试通过！")
```

运行测试：

```bash
cd /Users/chennan/pythonproject/demo/noval
python tests/test_plugin_system.py
```

### 1.7 验证兼容性

使用现有配置测试爬虫是否正常工作：

```bash
cd /Users/chennan/pythonproject/demo/noval
python -m backend.generic_crawler configs/config_ikbook8.json 9_9810
```

---

## ✅ 第一步完成检查清单

- [ ] 插件目录结构创建完成
- [ ] `base.py` 创建完成
- [ ] `builtin.py` 所有内置插件迁移完成
- [ ] `parser.py` 修改完成
- [ ] API端点添加完成
- [ ] 测试脚本通过
- [ ] 现有爬虫功能正常

**完成后，你的后端就拥有了完整的插件化能力！** 🎉

---

## 📌 第二步：前端基础准备（明天开始）

### 2.1 安装依赖

```bash
cd /Users/chennan/pythonproject/demo/noval/frontend
npm install reactflow
```

### 2.2 创建目录结构

```bash
cd src
mkdir -p pages/FlowEditor/nodes
mkdir -p pages/FlowEditor/components
```

### 2.3 创建基础文件

```bash
touch pages/FlowEditor/index.jsx
touch pages/FlowEditor/FlowEditor.css
touch pages/FlowEditor/nodeTypes.js
touch pages/FlowEditor/configGenerator.js
```

**详细实现请参考《插件化流程编辑器TODO.md》**

---

## 🎯 里程碑总览

| 阶段 | 任务 | 预计时间 | 状态 |
|------|------|----------|------|
| ✅ 阶段1 | 后端插件化 | 1天 | 进行中 |
| ⏳ 阶段2 | 前端基础 | 2天 | 待开始 |
| ⏳ 阶段3 | 配置生成 | 2天 | 待开始 |
| ⏳ 阶段4 | UI优化 | 2天 | 待开始 |
| ⏳ 阶段5 | 自定义插件 | 2天 | 待开始 |

---

## 💡 常见问题

### Q1: 插件化会影响性能吗？
A: 不会。插件调用是直接的方法调用，没有额外开销。

### Q2: 旧配置还能用吗？
A: 完全兼容！插件名称和原来的方法名一致。

### Q3: 如何添加自定义插件？
A: 创建类继承 `ProcessorPlugin`，用 `@PluginRegistry.register()` 装饰即可。

### Q4: 前端可视化编辑器难吗？
A: React Flow已经封装好了，主要工作是配置节点组件。

---

## 📚 参考资源

- 详细TODO: `docs/插件化流程编辑器TODO.md`
- React Flow文档: https://reactflow.dev/
- 清洗规则说明: `docs/清洗规则统一说明.md`

---

**祝你顺利！有问题随时问我 🚀**
